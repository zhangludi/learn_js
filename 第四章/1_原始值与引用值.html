<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // ECMAScript变量包含两种不同类型的数据： 原始值和引用值
    // 原始值就是简单的数据，undefined null Boolean Number String, 保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值
    // 引用值是保存在内存中的对象。与其他语言不同，js不允许直接访问内存位置，也就是不能直接操作对象的内存空间。在操作对象时，实际上操作的是对该对象的引用而非实际的对象本身。为此，保存引用值的变量是按引用访问的
    // 动态属性
    // let person = new Object()
    // person.name = 'test'
    // console.log(person.name) // test
    // let name = 'tome'
    // name.age = 17
    // console.log(name.age) // 17
    // 总结：只有引用值可以动态添加后面可以使用的属性
    // 原始类型的初始化可以是只使用原始字面量形式，如果使用的是new 关键字，则js 会创建一个object类型的实例，但其行为类似原始值
    // let name1 = 'name1'
    // let name2 = new String('name2')
    // name1.age = 16 
    // name2.age = 17
    // console.log(name1.age) // undefined
    // console.log(name2.age)  // 17
    // console.log(typeof name1) // string
    // console.log(typeof name2)  // object
    // 复制值
    // 除了存储方式不同，原始值和引用值在通过变量复制时也有所不同，
    // 通过变量把一个原始值赋值给另一个变量，原始值会被复制到新变量的位置，这两个变量是相互独立的
    // 引用值 从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置，区别在与，这里的复制的值实际上是一个指针，它指向存储在堆内存中的对象，错做完成之后
    // 实际上指向同一个对象
    // let obj1 = new Object()
    // let obj2 = obj1
    // obj1.name = 'rest'
    // console.loog(obj2.name) // rest

    // // 4.13 传递参数
    // // 参数num 和 变量count 之间互不干扰

    // function add (num) {
    //     num += 10
    //     return num
    // }
    // let count = 10
    // let res = add(count)
    // console.log(count) // 10
    // console.log(res) // 20
    // 如果是对象，可能没有那么清楚
    //1
    // function setName (obj) {
    //     obj.name = 'test'
    // }
    // let person = new Object()
    // setName(person)
    // console.log(person.name) // test
    //2 
    // function setName (obj) {
    //     obj.name = 'test'
    //     obj = new Object() // 本地对象在函数执行是被销毁
    //     obj.name = 'ssss'
    // }
    // let person = new Object()
    // setName(person)
    // console.log(person.name) // test
    // 4.1.4 确定类型  instanceof   Object Array RegExp
    // 4.2 作用域连增强
    // 执行上下文 全局上下文和函数上下文
    // try catch 
    // with
    // 4.22 变量声明
    // var 函数作用域生命
    // function add1 (num1, num2) {
    //     var sum = num1 + num2
    //     return sum
    // }
    // let res1 = add1(12, 14) // 26
    // console.log(sum) // 报错
    // 关于变量提升
    // function add2 (num1, num2) {
    //     sum1 = num1 + num2
    //     return sum1
    // }
    // let res12 = add1(12, 14) // 26
    // console.log(sum1) //  26

    // let 块级作用域生命  由最近的 {} 界定 if while function
    // let 不能被同时声明两次，var 可以
    // let 适合在循环中声明迭代变量，使用var声明的迭代变量会泄漏到循环外部
    for (var i=0; i< 10; i++) {}
    console.log(i) // 10
    for(let j=0; j< 10; j++) {}
    console.log(j) // ReferenceError: j没有定义
    // const 常量声明
    // 使用const 必须同时初始化某个值，一经声明则不可重新赋值
    //4 表示符查找
    // ···
</script>
</html>