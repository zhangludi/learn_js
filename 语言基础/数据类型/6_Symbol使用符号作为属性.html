<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // 字符串和数值可以作为属性的地方，符号也可以。包含对象字面量属性和Object.defineProperty()/Object.defineProperties(),对象字面量属性只能在计算行语法中使用符号作为属性
    let s1 = Symbol('foo'),
        s2 = Symbol('bar'),
        s3 = Symbol('baz'),
        s4 = Symbol('qux')
    // let o = {
    //     [s1]: 'foo val'
    // }
    // // console.log(o) // {Symbol(foo): foo val}

    // Object.defineProperty(o, s2, {value: 'bar val'})    
    // // console.log(o)  // {Symbol(foo): foo val, Symbol(bar): bar val}
    // Object.defineProperties(o, {
    //     [s3]: {value: 'baz value'},
    //     [s4]: {value: 'qux value'}, 
    // })
    // console.log(o)  // {Symbol(foo): foo val, Symbol(bar): bar val, Symbol(baz): baz val, Symbol(qux): qux val}
    // Object.getOwnpropertyNames() 返回对象实例的常规属性数组
    // Object.getOwnpropertySymbols() 返回对象实例的符号属性数组，与getOwnpropertyNames互斥
    // Object.getOwnPropertyDescriptors() 返回包含常规和符号属性描述符的对象
    // Reflect.ownKeys() 返回两种类型的键
    // let o = {
    //     [s1]: 'foo val',
    //     [s2]: 'bar val',
    //     baz: 'baz val',
    //     qux: 'qux val'
    // }
    // console.log(Object.getOwnPropertyNames(o)) // ['baz','qux']
    // console.log(Object.getOwnPropertySymbols(o)) // [Symbol(foo), Symbol(bar)]
    // console.log(Object.getOwnPropertyDescriptors(o)) // 
    
        //{
        //     "baz": {
        //         "value": "baz val",
        //         "writable": true,
        //         "enumerable": true,
        //         "configurable": true
        //     },
        //     "qux": {
        //         "value": "qux val",
        //         "writable": true,
        //         "enumerable": true,
        //         "configurable": true
        //     },
        //     "Symbol(foo)": {
        //         "value": "foo val",
        //         "writable": true,
        //         "enumerable": true,
        //         "configurable": true
        //     },
        //     "Symbol(bar)": {
        //         "value": "bar val",
        //         "writable": true,
        //         "enumerable": true,
        //         "configurable": true
        //     }
        // }
    // console.log(Reflect.ownKeys(o)) // ['baz','qux', Symbol(foo), Symbol(bar)]
    // 因为符号属性是对内存中符号的一个引用，所以之间创建并用作属性的符号不回丢失，但是如果没有显式的保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性健
    let o = {
        [Symbol('foo')]: 'foo val',
        [Symbol('bar')]: 'bar val'
    
    }
    // console.log(o) // {[Symbol('foo')]: 'foo val',[Symbol('bar')]: 'bar val'}
    let barSymbol = Object.getOwnPropertySymbols(o).find((symbol)=> symbol.toString().match(/bar/))
    console.log(barSymbol)
</script>
</html>